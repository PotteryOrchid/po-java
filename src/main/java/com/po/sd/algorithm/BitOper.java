package com.po.sd.algorithm;

/**
 * ####计算机是以补码的方式进行存储数据####
 * 原码表示法规定：用符号位和数值表示带符号数，正数的符号位用“0”表示，负数的符号位用“1”表示，数值部分用二进制形式表示。
 * 反码表示法规定：正数的反码与原码相同，负数的反码为对该数的原码除符号位外各位取反。
 * 补码表示法规定：正数的补码与原码相同，负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1. 正零和负零的补码相同，[+0]补=[-0]补=0000 0000B
 * 由补码求原码的过程跟由原码求补码的过程一样。
 *
 * ##原码##
 *
 * 00000000 00000000 00000000 00000101 是 5的 原码
 *
 * 10000000 00000000 00000000 00000101 是 -5的 原码
 *
 *
 * ##反码##
 *
 * 正数 00000000 00000000 00000000 00000101  的反码还是 00000000 00000000 00000000 00000101
 *
 * 负数 10000000 00000000 00000000 00000101  的反码则是 11111111 11111111 11111111 11111010
 *
 *
 * ##补码##
 *
 * 正数 00000000 00000000 00000000 00000101  的补码还是 00000000 00000000 00000000 00000101
 *
 * 负数 10000000 00000000 00000000 00000101  的补码 则是 反码 11111111 11111111 11111111 11111010 + 1 =
 * 11111111 11111111 11111111 11111011
 *
 *
 *
 *
 * ####位运算####
 *
 * 只能用于整形数据，对float和double类型进行位操作会被编译器报错。
 *
 * & : 与，两位数都是 1，结果才是 1。
 *
 * | : 或，两位数都是 0，结果才是 0。
 *
 * ^ : 异或，两位数不同，结果才是 1，同为 0 或 1，结果是 0。（0^1 = 1, 1^0 = 1, 0^0 = 0, 1^1 = 0）
 *
 * ~ : 取反，0 变 1，1 变 0。
 *
 * << : 左移，各二进位全部左移若干位，高位丢弃，地位补 0。
 *
 * >> : 右移，各二进位全部右移若干位，对于无符号数高位补 0，对于有符号数各编译器处理方式不同，有的补符号位（算数右移），有的补
 * 0（逻辑右移）。算术移位是相对于逻辑移位，它们在左移操作中都一样，低位补0即可，但在右移中逻辑移位的高位补0而算术移位的高位是补符号位。
 *
 *
 * 位运算用途：位操作技巧 判断奇偶 交换两数 变换符号 求绝对值 位操作压缩空间 筛素数 在高低位交换 二进制逆序 二进制中1的个数 缺失的数字
 *
 * Created by ZJ on 22/08/2018.
 */
public class BitOper {

  /**
   * 1、位运算判断偶数，根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。
   *
   * @param x Input Value
   * @return boolean
   */
  public static boolean isEven(int x) {
    if ((x & 1) == 1) {
      return false;
    }
    return true;
  }

  /**
   * 2、位运算交换两个数，异或满足交换率：a^b^c = a^c^b，一个数和自己异或的结果为0，并且任何数与0异或都会不变的。
   *
   * a = a ^ b
   * b = b ^ a = b ^ (a ^ b) = b ^ (b ^ a) = b ^ b ^ a = 0 ^ a = a
   * a = a ^ b = (a ^ b) ^ b = (a ^ b) ^ a = a ^ a ^ b = 0 ^ b = b
   *
   * @param a Input Value
   * @param b Input Value
   */
  public static int[] swap(int a, int b) {
    a ^= b;
    b ^= a;
    a ^= b;
    return new int[]{a, b};
  }

  /**
   * 3、位运算求负数 改变数据符号：正数求负数，负数求正数。 一个数可以通过对其取反后加1来得到正数。
   *
   * eg：
   *
   * 5 => 00000000 00000000 00000000 00000101 (计算机存储补码) => ~ + 1 => 11111111 11111111 11111111
   * 11111010 + 1 => 11111111 11111111 11111111 11111011 => -5
   *
   * -5 => 11111111 11111111 11111111 11111011 (计算机存储补码) => ~ + 1 => 00000000 00000000 00000000
   * 00000100 + 1 => 00000000 00000000 00000000 00000101 => 5
   *
   * @param a Input Value
   * @return int
   */
  public static int transSymbol(int a) {
    return ~a + 1;
  }

  public static void main(String[] args) {

    /**
     * Java int is 32 bits，所以计算机中存储的二进制为（计算机以补码形式存储）：
     * a = 15, bit data is 00000000 00000000 00000000 00001111.（补码）
     * b = -15, bit data is 11111111 11111111 11111111 11110001.（补码，原码为：10000000 00000000 00000000 00001111）
     *
     * a >> 2  =>  00000000 00000000 00000000 00000011(补码)  =>  00000000 00000000 00000000 00000011(原码)  =>  3
     * b >> 2  =>  11111111 11111111 11111111 11111100(补码)  =>  10000000 00000000 00000000 00000100(原码)  =>  -4
     */
    int a = 15, b = -15;
    System.out.printf("\rRes: 15 >> 2 => %d  ||  -15 >> 2 => %d \n", a >> 2, b >> 2);

    /**
     * 奇偶判断 \r 回车 \n 换行
     */
    System.out.printf("\r是否偶数：%s \r", BitOper.isEven(78));

    /**
     * 交换两个数
     */
    int[] res = BitOper.swap(a, b);
    System.out.printf("\ra = %s  ||  b = %s \r", res[0], res[1]);

    System.out.printf("Transform symbol: %d\r",BitOper.transSymbol(-78));
  }
}
