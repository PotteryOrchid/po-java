package com.po.sd.algorithm;

/**
 * ####计算机是以补码的方式进行存储数据####
 * 原码表示法规定：用符号位和数值表示带符号数，正数的符号位用“0”表示，负数的符号位用“1”表示，数值部分用二进制形式表示。
 * 反码表示法规定：正数的反码与原码相同，负数的反码为对该数的原码除符号位外各位取反。
 * 补码表示法规定：正数的补码与原码相同，负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1. 正零和负零的补码相同，[+0]补=[-0]补=0000 0000B
 * 由补码求原码的过程跟由原码求补码的过程一样。
 *
 * ##原码##
 *
 * 00000000 00000000 00000000 00000101 是 5的 原码
 *
 * 10000000 00000000 00000000 00000101 是 -5的 原码
 *
 *
 * ##反码##
 *
 * 正数 00000000 00000000 00000000 00000101  的反码还是 00000000 00000000 00000000 00000101
 *
 * 负数 10000000 00000000 00000000 00000101  的反码则是 11111111 11111111 11111111 11111010
 *
 *
 * ##补码##
 *
 * 正数 00000000 00000000 00000000 00000101  的补码还是 00000000 00000000 00000000 00000101
 *
 * 负数 10000000 00000000 00000000 00000101  的补码 则是 反码 11111111 11111111 11111111 11111010 + 1 =
 * 11111111 11111111 11111111 11111011
 *
 *
 *
 *
 * ####位运算####
 *
 * 只能用于整形数据，对float和double类型进行位操作会被编译器报错。
 *
 * & : 与，两位数都是 1，结果才是 1。
 *
 * | : 或，两位数都是 0，结果才是 0。
 *
 * ^ : 异或，两位数不同，结果才是 1，同为 0 或 1，结果是 0。（0^1 = 1, 1^0 = 1, 0^0 = 0, 1^1 = 0）
 *
 * ~ : 取反，0 变 1，1 变 0。
 *
 * << : 左移，各二进位全部左移若干位，高位丢弃，地位补 0。
 *
 * >> : 右移，各二进位全部右移若干位，对于无符号数高位补 0，对于有符号数各编译器处理方式不同，有的补符号位（算数右移），有的补
 * 0（逻辑右移）。算术移位是相对于逻辑移位，它们在左移操作中都一样，低位补0即可，但在右移中逻辑移位的高位补0而算术移位的高位是补符号位。
 *
 *
 * 位运算用途：位操作技巧 判断奇偶 交换两数 变换符号 求绝对值 位操作压缩空间 筛素数 在高低位交换 二进制逆序 二进制中1的个数 缺失的数字
 *
 * Created by ZJ on 22/08/2018.
 */
public class BitOper {

  public static void main(String[] args) {
    /**
     * Java int is 32 bits，所以计算机中存储的二进制为（计算机以补码形式存储）：
     * a = 15, bit data is 00000000 00000000 00000000 00001111.（补码）
     * b = -15, bit data is 11111111 11111111 11111111 11110001.（补码，原码为：10000000 00000000 00000000 00001111）
     *
     * a >> 2  =>  00000000 00000000 00000000 00000011(补码)  =>  00000000 00000000 00000000 00000011(原码)  =>  3
     * a >> 2  =>  11111111 11111111 11111111 11111100(补码)  =>  10000000 00000000 00000000 00000100(原码)  =>  -4
     */
    int a = 15, b = -15;
    System.out.printf("\nRes: 15 >> 2 => %d  ||  -15 >> 2 => %d \n", a >> 2, b >> 2);
  }
}
